---
title: "DE_EdgeR"
author: "Heesoo Song"
date: '2021 11 28 '
output: html_document
---

This analysis is based on two tutorials:
  - https://hbctraining.github.io/scRNA-seq_online/lessons/pseudobulk_DESeq2_scrnaseq.html
  - https://bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf
  
The first tutorial gave idea about making aggregate matrix as an alternative of using Muscat. Muscat unfortunately kept rised errors. Although this tutorial was a bit manual, but created what Muscat does with aggregateData() function.

The second tutorial is about the analysis of time course data using EdgeR. 

```{r, verbose = FALSE}
library(SeuratObject)
library(Seurat)
library(nichenetr)
library(tidyverse)
library("ggplot2")
library(muscat)
```

```{r, cache = TRUE}
# Load processed expression data of interacting cells
hepatectomy_expression = readRDS("C:/Users/pc/Desktop/MastersProject/Dynamic_NicheNet/seurat_obj_phx_25102021.rds")

# Total 91021 cells, with 5000 genes
```

```{r}
celltype_OI <- c("cholangiocyte","endothelial","hepatocyte","kupffer","monocyte","neutrophil","stellate")
```

```{r}
hepa_celltypeOI = subset(x = hepatectomy_expression, idents = celltype_OI)
```

```{r, verbose = FALSE}
library(SingleCellExperiment)
library(purrr)
```

# Create Aggregate Count Matrix

```{r}
# Extract raw counts and metadata to create SingleCellExperiment object
counts <- hepa_celltypeOI@assays$RNA@counts
metadata <- hepa_celltypeOI@meta.data

# Set up metadata as desired for aggregation and DE analysis
metadata$cluster_id <- factor(hepa_celltypeOI@active.ident)
#metadata$cluster_sample <- paste0(factor(metadata$cluster_id), ".", factor(metadata$time_experiment)) # This line is added

# Create single cell experiment object
sce <- SingleCellExperiment(assays = list(counts = counts),
                            colData = metadata)

```


```{r}
#Named vector of cluster names
kids <- purrr::set_names(levels(sce$cluster_id))
kids

#Total number of clusters
nk <- length(kids)
nk

#Named vector of sample names
sids <- purrr::set_names(levels(factor(sce$time_experiment)))
#sids <- purrr::set_names(levels(factor(sce$cluster_sample)))
sids[1:10]

#Total number of samples
ns <- length(sids)
ns
```
```{r}
# Generate sample level metadata

## Determine the number of cells per sample
table(sce$time_experiment)
#table(sce$cluster_sample)

## Turn named vector into a numeric vector of cells per sample
n_cells <- as.numeric(table(sce$time_experiment))
#n_cells <- as.numeric(table(sce$cluster_sample))

## Determine how to reorder the samples (rows) of the metadata to match the order of sample names in sids vector
m <- match(sids, sce$time_experiment)
#m <- match(sids, sce$cluster_sample)


## Create the sample level metadata by combining the reordered metadata with the number of cells corresponding to each sample.
ei <- data.frame(colData(sce)[m, ], 
                 n_cells, row.names = NULL) %>% 
  select(-"cluster_id")
head(ei)
```
```{r}
# Identify groups for aggregation of counts
groups <- colData(sce)[, c("cluster_id", "time_experiment")]
#groups <- colData(sce)[, c("cluster_id", "cluster_sample")]
```



```{r}
#install.packages('Matrix.utils')
library(Matrix.utils)
pb <- aggregate.Matrix(t(counts(sce)),
                       groupings = groups, fun = "sum")

class(pb)
dim(pb)
pb[1:6, 1:6]
```

```{r}
# Not every cluster is present in all samples; create a vector that represents how to split samples
# But actually we do have all cell types! :) Maybe skip this step
splitf <- sapply(stringr::str_split(rownames(pb), pattern="_", n=2), '[', 1)
```

```{r}
# Turn into a list and split the list into components for each cluster and transform, so rows are genes and columns are samples and make rownames as the sample IDs
library(magrittr)
pb <- split.data.frame(pb, 
                       factor(splitf)) %>%
  lapply(function(u) 
    set_colnames(t(u), 
                 stringr::str_extract(rownames(u), "(?<=_)[:alnum:]+_phase_[0-9]")))

class(pb)

# Explore the different components of list
str(pb)
```
```{r}
# Print out the table of cells in each cluster-sample group
options(width = 100)
table(sce$cluster_id, sce$time_experiment)
#table(sce$cluster_id, sce$cluster_sample)
```

# 2. Differential gene expression
The aim is to examine the relationship between gene abundances and time points per each cell-type. Given enough number of time points, it is reasonable to assume smooth changes in gene expression. In this way, polynomial or a cubic spline curve can be used to model gene expression along time with a certain number of degrees of freedom.

First, prepare matrix for DE analysis.
```{r}
# Get sample names for each of the cell type clusters

# prep. data.frame for plotting
get_sample_ids <- function(x){
  pb[[x]] %>%
    colnames()
}

de_samples <- map(1:length(kids), get_sample_ids) %>%
  unlist()
```

```{r}
# Get cluster IDs for each of the samples

samples_list <- map(1:length(kids), get_sample_ids)

get_cluster_ids <- function(x){
  rep(names(pb)[x], 
      each = length(samples_list[[x]]))
}

de_cluster_ids <- map(1:length(kids), get_cluster_ids) %>%
  unlist()
```

```{r}
# Create a data frame with the sample IDs, cluster IDs and condition

gg_df <- data.frame(cluster_id = de_cluster_ids,
                    sample_id = de_samples)


metadata <- gg_df %>%
  dplyr::select(cluster_id, sample_id)

metadata$cluster_id <- factor(metadata$cluster_id)
#metadata$cluster_sample <- paste0(factor(metadata$cluster_id), ".", factor(metadata$sample_id)) # This line is added

head(metadata, n = 10)
```


Perform DE analysis on each cell type.
clusters = c("cholangiocyte", "endothelial", "hepatocyte", "kupffer", "monocyte", "neutrophil", "stellate")
```{r}
# Subset dataset to cluster of interest

## Generate vector of cluster IDs
clusters <- levels(metadata$cluster_id)
clusters

## DE analysis on cholangiocyte
### Subset the metadata to only
cluster_metadata <- metadata[which(metadata$cluster_id == clusters[3]), ]
head(cluster_metadata)

### Assign the rownames of the metadata to be the sample IDs
rownames(cluster_metadata) <- cluster_metadata$sample_id
cluster_metadata

### Subset the counts to only the B cells
counts <- pb[[clusters[3]]]

cluster_counts <- as.data.frame(as.matrix(counts[, which(colnames(counts) %in% rownames(cluster_metadata))]))

#reorder columns by time point
cluster_counts <- cluster_counts[, c(1,6,10,2,5,7,8,9,11,12,3,4)]

### Check that all of the row names of the metadata are the same and in the same order as the column names of the counts
all(rownames(cluster_metadata) == colnames(cluster_counts))
```

Explore aggregated count data by MDS (multi-dimensional scaling) plots. This visualizes the differences between the expression profiles of different samples (cholangiocyte) in two dimensions.
```{r}
library(edgeR)
plotMDS(cluster_counts, labels=colnames(cluster_counts))
```


```{r}
#hours <- c(0, 12, 120, 168, 24, 3, 36, 48, 48, 6, 72, 96)
hours <- c(0, 3, 6, 12, 24, 36, 48, 48, 72, 96, 120, 168)
# X <- poly(hours, degree=3)
# design <- model.matrix(~X)
# design
```

Use cubic regression spline curve with 3 degrees of freedom. The advantage of using a cubic spline curve is that it provides more stable fit at the end points compared to a polynomial. The spline curve with 3 degrees of freedom has 2 knots where cucbic polynomicals are splined together.
```{r}
library(splines)
X <- ns(hours, df = 3)
design <- model.matrix(~X)
design
```
Estimate dispersion. The negative binomial (NB) dispersion is estimated. This returns the **DGEList** object with additional entries for the estimated NB dispersion for each gene.
```{r}
y <- DGEList(counts = cluster_counts, group = hours)
y <- estimateDisp(y, design)
sqrt(y$common.dispersion)

# plot the tagwise dispersion against log2-CPM (counts per million)
plotBCV(y)
```
```{r}
#install.packages("statmod")
```

Fit a quasi-likelihood NB generalized log-linear model
```{r}
fit <- glmQLFit(y, design, robust=TRUE)
plotQLDisp(fit)
```

Fit a quasi-likelihood negative binomial generalized log-linear model to count data.
```{r}
fit <- glmQLFTest(fit, coef=2:4)
```

```{r}
# Genes with most significant time effects
tab <- as.data.frame(topTags(fit, n=100))
tab
```

Change ENSEMBL gene IDs to gene symbols
```{r}
#BiocManager::install("org.Mm.eg.db")
library(org.Mm.eg.db)
IDlist <- mapIds(org.Mm.eg.db, rownames(tab), keytype="ENSEMBL", column="SYMBOL", multiVals="first")
tab$Symbol <- IDlist
tab
```

Multiple testing across genes and contrasts. The default threshold is p-value < 0.05. 
```{r}
summary(decideTests(fit))
```

```{r}
logCPM.obs <- cpm(y, log=TRUE, prior.count=fit$prior.count)
logCPM.fit <- cpm(fit, log=TRUE)
```

```{r}
par(mfrow=c(2,2))
for(i in 1:4) {
  FlybaseID <- row.names(tab)[i]
  Symbol <- tab$Symbol[i]
  logCPM.obs.i <- logCPM.obs[FlybaseID,]
  logCPM.fit.i <- logCPM.fit[FlybaseID,]
  plot(hours, logCPM.obs.i, ylab="log-CPM", main=Symbol, pch=16)
  lines(hours, logCPM.fit.i, col="red", lwd=2)
}
```


